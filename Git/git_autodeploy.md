# Git: автодеплой при merge — базово и без воды

## 1) База: что такое автодеплой при merge
**Автодеплой при merge** — это когда каждый новый код, слитый в основную ветку (`main`), **сам** проходит цепочку *сборка → проверки → выкатывание в прод*, без твоих ручных действий.

Коротко как это выглядит:
```
merge в main → триггер → CI запускает пайплайн → билды/тесты → деплой → новый прод
```
Зачем это нужно:
- скорость и предсказуемость релизов;
- меньше человеческих ошибок;
- всегда один и тот же, проверенный процесс.

> Правило: **автодеплой** — это не про «куда», а про **процесс**: *кто замечает merge, кто билдит, кто деплоит*.

---

## 2) Где автодеплой есть «из коробки» (Render/Vercel)
Платформы вроде **Render** и **Vercel** сами следят за твоим репозиторием.

Как это работает на Render/Vercel:
1. Подключаешь GitHub/GitLab-репозиторий.
2. Указываешь ветку для продакшна (обычно `main`).
3. При каждом merge/push в `main` платформа автоматически:
   - тянет код,
   - ставит зависимости,
   - билдит,
   - выкатывает новый билд.

Что важно понимать:
- Автодеплой **уже включён**: настраивать CI не обязательно.
- Но проверки качества (тесты/линт/аудит) по умолчанию **не блокируют** деплой. Если билд прошёл — оно развернёт, даже если у тебя нет тестов.

**Когда этого достаточно**
- Пет-проекты, MVP, личные сайты, небольшие проды.
- Нужно быстро и без DevOps-заморочек.

---

## 3) Где автодеплой **не** из коробки (AWS/свои сервера)
На **AWS** (EC2/ECS/EKS, Lambda) или **своём VPS/сервере** платформа **не знает** про твой merge. Тебе нужно **самому собрать процесс**:

Минимальные роли в цепочке:
- **Триггер** (кто замечает merge): GitHub Actions/GitLab CI.
- **Сборка и проверки**: тесты, линт, билд (часто в Docker).
- **Поставка артефакта**: публикация контейнера (например, в AWS ECR).
- **Оркестрация деплоя**: раскатка на EC2/ECS/EKS/Lambda или на твой сервер (через SSH/Ansible/Terraform и т.п.).

В реальности это выглядит так:
```
merge в main
 → GitHub Actions запускает workflow
 → npm ci && npm test && npm run build
 → docker build && docker push (в ECR/registry)
 → команда деплоя (ECS update service / kubectl apply / ssh && docker pull && restart)
 → прод обновлён
```

**Когда это нужно**
- Ты хочешь полный контроль (сети, приватные VPC, секреты, масштабирование, цену).
- Нужны нестандартные окружения, фоновые воркеры, очереди, сложный сетап.
- Есть требования безопасности/сертификации, которые PaaS не закрывает.

---

## 4) Ключевая разница: Render vs AWS (самое важное)
| Вопрос | Render/Vercel (PaaS) | AWS/свой сервер |
|---|---|---|
| Кто «видит» merge | Платформа (встроенно) | **Ты** через CI (GitHub Actions) |
| Кто билдит | Платформа | Твой CI (часто Docker) |
| Кто деплоит | Платформа | Ты: скрипты/инфраструктура (ECS/EKS/EC2/SSH) |
| Сложность | Низкая | Средняя/Высокая |
| Контроль и гибкость | Ограничены тарифом/фичами | Максимальные |
| По умолчанию есть автодеплой? | **Да** | **Нет**, надо **настраивать** |

> Вывод: **на Render автодеплой включён по умолчанию** (достаточно подключить репо). **На AWS/серверах автодеплой не включён** — его нужно **явно настроить** через CI/CD.

---

## 5) Практические шаблоны

### 5.1. «Лёгкий путь» (Render)
- Подключи репозиторий → выбери `main` как прод → зафиксируй Build Command и Start Command.
- (Опционально) добавь Previews для PR-веток.
- (Желательно) добавь в проект базовый CI на PR (линт/тесты), чтобы не пускать мусор в `main`.

### 5.2. «Кастомный путь» (AWS/свой сервер)
**GitHub Actions:**
```yaml
name: CI/CD (AWS)

on:
  push:
    branches: [ main ]

jobs:
  build-test-ship:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Use Node
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Install deps
        run: npm ci

      - name: Test
        run: npm test -- --ci

      - name: Build
        run: npm run build

      # Собираем контейнер и публикуем (пример с ECR)
      - name: Configure AWS creds
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: us-east-1
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & Push image
        run: |
          IMAGE=your-account.dkr.ecr.us-east-1.amazonaws.com/your-app
          docker build -t $IMAGE:$GITHUB_SHA .
          docker push $IMAGE:$GITHUB_SHA
          docker tag $IMAGE:$GITHUB_SHA $IMAGE:latest
          docker push $IMAGE:latest

      # Деплой (вариант: ECS)
      - name: Update ECS service
        run: |
          aws ecs update-service             --cluster your-cluster             --service your-service             --force-new-deployment
```

Идея ясна: **ты сам собираешь «кубики» процесса**. Без этого на AWS ничего само не поедет.

---

## 6) Краткий чек-лист принятия решения
- **Нужен быстрый старт, минимум DevOps?** → Render/Vercel.
- **Нужны тонкие настройки сети/безопасности/масштабирования?** → AWS/сервера + CI/CD.
- **Хочешь и быстро, и надёжно?** → Render для фронта, бэкенд/воркеры — в AWS через Actions.

---

## 7) TL;DR
- Автодеплой при merge — это про *процесс*, который запускается при попадании кода в `main`.
- На Render/Vercel он **есть из коробки**: merge → платформа всё сделает.
- На AWS/серверах его **нет по умолчанию**: **сам** настраиваешь CI/CD (Actions/GitLab CI) + деплой (ECS/EKS/EC2/SSH).
- Если автодеплой «не заводится» сам — значит, нужно **настроить три вещи**: триггер (CI), сборку/проверки, и механизм выката на твой рантайм.
