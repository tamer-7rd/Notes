# Сравнение концепции Объектов в JavaScript и Python

Этот конспект обобщает фундаментальные различия в том, как JavaScript и Python воспринимают типы данных, объекты и функции.

---

## 1. Функции как объекты

В обоих языках функции являются **«гражданами первого класса» (First-class citizens)**. Это означает, что функции можно присваивать переменным, передавать как аргументы и возвращать из других функций.

### JavaScript
Функция в JS — это **вызываемый объект (callable object)**.
- **Наследование:** `function` наследуется от `Object`.
- **Свойства:** Функции можно присваивать пользовательские свойства и методы.
- **Тип:** Оператор `typeof` возвращает `'function'`, но `instanceof Object` вернет `true`.

```javascript
function greet() {}
greet.lang = "RU"; // Можно добавить свойство прямо к функции
console.log(greet instanceof Object); // true
```

### Python
В Python функция — это полноценный объект класса `function`.
- **Всё есть объект:** Функция — это такой же объект, как и число или список.
- **Атрибуты:** Можно динамически добавлять атрибуты к объектам функций.

```python
def greet(): pass
greet.lang = "RU" # Можно добавить атрибут
print(isinstance(greet, object)) # True
```

---

## 2. Философия: «Всё есть объект» vs «Примитивы и Объекты»

Это ключевое архитектурное различие между языками.

### Python: «Всё есть объект» (Everything is an object)
В Python **абсолютно всё** является объектом: числа, строки, функции, модули и даже сами классы.
- **Универсальность:** Любая сущность имеет тип, адрес в памяти и методы.
- **Пример:** Число `5` в Python — это сложный объект, содержащий методы для арифметических операций (`__add__`, `__mul__` и т.д.).

```python
x = 10
# У числа есть методы!
print(x.bit_length()) 
```

**Почему так сделано?** Для унификации. Правила работы с переменными одинаковы для всего. Вы можете передать число, функцию или класс в другую функцию одинаковым способом.

### JavaScript: Разделение на Примитивы и Объекты
JavaScript разделяет мир данных на две касты ради производительности.

#### А. Примитивы (Primitives)
Простые типы данных, хранящиеся в стеке. Они **не** являются объектами. Они легковесны.
*   `string`, `number`, `boolean`, `null`, `undefined`, `symbol`, `bigint`.
*   **Важно:** Примитивы **не могут хранить свойства**.

#### Б. Объекты (Objects)
Сложные структуры данных, хранящиеся в куче (heap).
*   `Object {}`, `Array []`, `Function`, `Date`, `Map` и т.д.

---

## 3. Магия JavaScript: Autoboxing (Обертки)

Если примитивы в JS (например, строка) не являются объектами, почему у них есть методы типа `.toUpperCase()`?

```javascript
let str = "hello";
console.log(str.toUpperCase()); // "HELLO"
```

Здесь работает механизм **Autoboxing**:
1.  Когда вы пытаетесь вызвать метод у примитива, JS **на лету** создает невидимый временный объект-обертку (`new String("hello")`).
2.  Этот объект имеет методы, один из которых выполняется.
3.  Сразу после выполнения временный объект **уничтожается**.

Если попытаться присвоить свойство примитиву, оно исчезнет, так как будет записано во временный объект, который тут же удалится:

```javascript
let num = 5;
num.prop = "test"; // JS создаст обертку Number(5), запишет свойство, и удалит обертку
console.log(num.prop); // undefined
```

---

## Сводная таблица сравнения

| Характеристика | Python | JavaScript |
| :--- | :--- | :--- |
| **Функция** | Объект | Объект (вызываемый) |
| **Число (например, 5)** | **Объект** (с методами) | **Примитив** (просто данные) |
| **Строка** | **Объект** | **Примитив** (с авто-оберткой) |
| **Массив / Список** | Объект (`list`) | Объект (`Array`) |
| **Добавление свойств к числу** | Нельзя (int неизменяем, но это объект) | Нельзя (это примитив) |
| **Философия** | Универсальность, согласованность | Производительность, простота |
