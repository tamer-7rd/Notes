# Как работает интернет: DNS, HTTP, HTTPS — простыми словами

Этот конспект объясняет, что происходит, когда ты открываешь сайт в браузере. Каждый шаг разобран простым языком.

---

## 1. DNS — телефонная книга интернета

### Что это такое?

**DNS (Domain Name System)** — это система, которая переводит человеческие адреса в адреса, понятные компьютерам.

**Аналогия:** Как телефонная книга. Ты ищешь "Иванов Иван" (это `google.com`), а книга говорит тебе номер телефона (это IP-адрес `142.250.74.46`).

### Зачем это нужно?

Компьютеры понимают только цифры (IP-адреса), например `93.184.216.34`. Людям проще запомнить `example.com`. DNS переводит одно в другое.

### Как это работает? (Пошагово)

Когда ты вводишь `google.com` в браузере, происходит следующее:

#### Шаг 1: Проверка памяти (Кэш)
Браузер сначала проверяет свою память: "Я уже заходил на `google.com` недавно?" Если да — берёт адрес из памяти (это быстро, 0мс).

#### Шаг 2: Справочная твоего провайдера
Если в памяти нет, браузер спрашивает у твоего интернет-провайдера (Ростелеком, МГТС и т.д.): "Какой IP у `google.com`?"

Провайдер тоже проверяет свою память. Если знает — отвечает сразу.

#### Шаг 3: Главная справочная интернета (Root Server)
Если провайдер не знает, он идёт к главным серверам интернета (их 13 групп по всему миру). Это как справочная служба, которая знает: "За зону `.com` отвечает такой-то сервер".

#### Шаг 4: Справочная зоны `.com` (TLD Server)
Главная справочная говорит: "Иди к серверу зоны `.com`, он знает про все домены с `.com`".

#### Шаг 5: Справочная Google (Authoritative Server)
Сервер `.com` говорит: "За домен `google.com` отвечает сервер Google (например, на Route53 или Cloudflare)". Этот сервер и знает точный IP-адрес.

#### Шаг 6: Ответ
IP-адрес возвращается обратно по цепочке: Google → `.com` → Root → Провайдер → Твой браузер.

**Время:** Обычно 20-200 миллисекунд (если не было в кэше).

### Типы записей DNS (что можно записать в "телефонной книге")

```
┌─────────┬──────────────────┬─────────────────────────────────────────────────────────┬─────────────────────────────────────────┐
│ Тип     │ Что это          │ Простыми словами                                        │ Пример                                  │
├─────────┼──────────────────┼─────────────────────────────────────────────────────────┼─────────────────────────────────────────┤
│ A       │ IPv4 адрес       │ Обычный адрес (4 числа)                                 │ example.com -> 93.184.216.34            │
├─────────┼──────────────────┼─────────────────────────────────────────────────────────┼─────────────────────────────────────────┤
│ AAAA    │ IPv6 адрес       │ Новый формат адреса (длиннее)                           │ example.com -> 2606:2800:220...         │
├─────────┼──────────────────┼─────────────────────────────────────────────────────────┼─────────────────────────────────────────┤
│ CNAME   │ Псевдоним        │ "Этот адрес = другой адрес"                             │ www.example.com -> example.com          │
├─────────┼──────────────────┼─────────────────────────────────────────────────────────┼─────────────────────────────────────────┤
│ MX      │ Почтовый сервер  │ "Письма на этот домен отправляй сюда"                   │ example.com -> smtp.google.com          │
├─────────┼──────────────────┼─────────────────────────────────────────────────────────┼─────────────────────────────────────────┤
│ TXT     │ Текстовая запись │ Любая текстовая информация (проверка домена, антиспам) │ v=spf1 include:_spf.google.com          │
├─────────┼──────────────────┼─────────────────────────────────────────────────────────┼─────────────────────────────────────────┤
│ NS      │ Сервер имён      │ "Кто отвечает за DNS этого домена"                      │ ns1.awsdns.com                          │
└─────────┴──────────────────┴─────────────────────────────────────────────────────────┴─────────────────────────────────────────┘
```

---

## 2. HTTP — язык общения браузера и сервера

### Что это такое?

**HTTP (HyperText Transfer Protocol)** — это правила, по которым браузер и сервер общаются друг с другом.

**Аналогия:** Как протокол в дипломатии. Есть определённые правила, как послы обмениваются сообщениями.

### Как выглядит запрос? (Что браузер отправляет серверу)

Когда ты открываешь сайт, браузер отправляет примерно такое сообщение:

```http
GET /api/users/1 HTTP/1.1
Host: api.example.com
Authorization: Bearer abc123...
Accept: application/json
User-Agent: Mozilla/5.0...
```

**Разбор по строкам:**

1.  **`GET /api/users/1 HTTP/1.1`** — "Дай мне (`GET`) файл по адресу `/api/users/1`, используя протокол HTTP версии 1.1".
2.  **`Host: api.example.com`** — "Я обращаюсь к серверу `api.example.com`" (важно, если на одном IP несколько сайтов).
3.  **`Authorization: Bearer abc123...`** — "Вот мой пропуск (токен) для доступа".
4.  **`Accept: application/json`** — "Я понимаю JSON, пришли данные в этом формате".
5.  **`User-Agent: Mozilla/5.0...`** — "Я браузер Chrome версии такой-то".

### Как выглядит ответ? (Что сервер отправляет обратно)

Сервер отвечает примерно так:

```http
HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: max-age=3600

{ "id": 1, "name": "Alice" }
```

**Разбор:**

1.  **`HTTP/1.1 200 OK`** — "Всё хорошо, код ответа 200 (успех)".
2.  **`Content-Type: application/json`** — "Данные в формате JSON".
3.  **`Cache-Control: max-age=3600`** — "Можешь сохранить это в памяти на 1 час (3600 секунд)".
4.  **Пустая строка** — разделитель между заголовками и телом.
5.  **`{ "id": 1, "name": "Alice" }`** — сами данные (тело ответа).

### Коды ответов (Status Codes)

```
┌─────────┬──────────────────────────────┬─────────────────────────────────┐
│ Код     │ Что означает                 │ Пример                          │
├─────────┼──────────────────────────────┼─────────────────────────────────┤
│ 200     │ Всё хорошо, данные получены  │ Успешный запрос                 │
├─────────┼──────────────────────────────┼─────────────────────────────────┤
│ 301/302 │ Редирект (перенаправление)   │ "Сайт переехал, иди туда"       │
├─────────┼──────────────────────────────┼─────────────────────────────────┤
│ 404     │ Не найдено                   │ "Такой страницы нет"            │
├─────────┼──────────────────────────────┼─────────────────────────────────┤
│ 500     │ Ошибка сервера               │ "Сервер сломался"               │
├─────────┼──────────────────────────────┼─────────────────────────────────┤
│ 401     │ Не авторизован               │ "Ты не залогинен"               │
├─────────┼──────────────────────────────┼─────────────────────────────────┤
│ 403     │ Запрещено                    │ "У тебя нет прав"               │
└─────────┴──────────────────────────────┴─────────────────────────────────┘
```

### Методы HTTP (что можно попросить сделать)

```
┌─────────┬───────────────────────────────┬──────────────────────────────────────────┬────────────────────────────────────┐
│ Метод   │ Что делает                    │ Простыми словами                         │ Пример                             │
├─────────┼───────────────────────────────┼──────────────────────────────────────────┼────────────────────────────────────┤
│ GET     │ Получить данные               │ "Дай мне информацию"                     │ Получить список пользователей      │
├─────────┼───────────────────────────────┼──────────────────────────────────────────┼────────────────────────────────────┤
│ POST    │ Создать что-то новое          │ "Создай новый ресурс"                    │ Создать нового пользователя        │
├─────────┼───────────────────────────────┼──────────────────────────────────────────┼────────────────────────────────────┤
│ PUT     │ Полностью заменить            │ "Замени всё на новое"                    │ Обновить все данные пользователя   │
├─────────┼───────────────────────────────┼──────────────────────────────────────────┼────────────────────────────────────┤
│ PATCH   │ Частично обновить             │ "Измени только это поле"                 │ Изменить только имя пользователя   │
├─────────┼───────────────────────────────┼──────────────────────────────────────────┼────────────────────────────────────┤
│ DELETE  │ Удалить                       │ "Удали это"                              │ Удалить пользователя               │
├─────────┼───────────────────────────────┼──────────────────────────────────────────┼────────────────────────────────────┤
│ OPTIONS │ Узнать разрешения             │ "Что мне можно делать?"                  │ Используется для CORS              │
├─────────┼───────────────────────────────┼──────────────────────────────────────────┼────────────────────────────────────┤
│ HEAD    │ Получить только заголовки     │ "Дай инфу о файле, но не сам файл"       │ Проверить, существует ли файл      │
└─────────┴───────────────────────────────┴──────────────────────────────────────────┴────────────────────────────────────┘
```

**Важно:** `GET` и `HEAD` не должны изменять данные на сервере (идемпотентные). Можно вызывать сколько угодно раз — результат не изменится.

### Версии HTTP (эволюция)

#### HTTP/1.1 (старая, но всё ещё популярная)

**Проблема:** Если нужно загрузить 10 картинок, браузер делает 10 отдельных запросов. Каждый запрос ждёт ответа предыдущего (или открывает новое соединение).

**Решение:** Keep-Alive — держать соединение открытым, чтобы не тратить время на "рукопожатие" каждый раз.

#### HTTP/2 (современная)

**Что улучшилось:**
-   **Multiplexing** — можно отправлять много запросов одновременно в одном соединении (как несколько разговоров по одному телефону).
-   **Сжатие заголовков** — заголовки (Host, User-Agent и т.д.) сжимаются, чтобы не повторять одно и то же.
-   **Server Push** — сервер может сам отправить файлы, которые, по его мнению, понадобятся (например, CSS для страницы).

**Проблема:** Если потеряется один пакет данных, все запросы в этом соединении ждут, пока он не восстановится.

#### HTTP/3 (QUIC) (самая новая)

**Что улучшилось:**
-   Работает поверх **UDP** (вместо TCP) — если потерялся один пакет, остальные продолжают работать.
-   Встроенное шифрование (TLS) — безопасность из коробки.
-   Быстрее на плохих сетях (мобильный интернет, Wi-Fi с помехами).

---

## 3. TCP и HTTPS — почему соединение "дорогое"

### Что такое TCP?

**TCP (Transmission Control Protocol)** — это протокол, который гарантирует, что данные дойдут до получателя в правильном порядке.

**Аналогия:** Как заказное письмо с уведомлением. Ты знаешь, что письмо дошло, и оно пришло в правильном порядке.

### TCP Handshake (рукопожатие) — почему это занимает время

Прежде чем отправить хоть байт данных, нужно "поздороваться":

1.  **Клиент → Сервер:** "Привет! Хочу соединиться" (SYN).
2.  **Сервер → Клиент:** "Привет! Давай соединимся" (SYN-ACK).
3.  **Клиент → Сервер:** "Окей, договорились!" (ACK).

**Время:** Это занимает примерно 1.5 RTT (Round Trip Time — время туда-обратно сигнала). Если пинг до сервера 100мс, мы теряем 150мс просто на "приветствие".

**RTT (Round Trip Time)** — это время, за которое сигнал доходит до сервера и возвращается обратно. Если пинг 50мс, значит сигнал идёт туда 25мс и обратно 25мс.

### Что такое HTTPS?

**HTTPS** — это HTTP, но зашифрованный. Буква "S" означает "Secure" (безопасный).

**Зачем:** Чтобы никто не мог перехватить и прочитать твои данные (пароли, банковские карты, личные сообщения).

### TLS Handshake (как устанавливается безопасное соединение)

Когда ты заходишь на сайт с HTTPS, происходит дополнительное "рукопожатие" для обмена ключами шифрования:

1.  **Client Hello:** Браузер говорит: "Привет! Я умею такие-то способы шифрования. Выбери один".
2.  **Server Hello + Certificate:** Сервер отвечает: "Окей, выберу этот способ. Вот мой паспорт (сертификат), чтобы ты убедился, что это действительно я".
3.  **Проверка сертификата:** Браузер проверяет сертификат (подписан ли он доверенной организацией).
4.  **Обмен ключами:** Браузер и сервер договариваются о секретном ключе для шифрования данных.
5.  **Finished:** "Всё готово, теперь всё зашифровано, можно общаться".

**Время:** Это добавляет ещё примерно 1-2 RTT (100-200мс на медленном интернете).

### Симметричное vs Асимметричное шифрование

**Асимметричное шифрование (Public/Private Key):**
-   Есть два ключа: публичный (все могут видеть) и приватный (секретный).
-   Что зашифровано публичным ключом, расшифровывается только приватным.
-   **Плюс:** Безопасно.
-   **Минус:** Медленно (используется только для рукопожатия).

**Симметричное шифрование:**
-   Один ключ для шифрования и расшифровки.
-   **Плюс:** Быстро (используется для передачи данных после рукопожатия).
-   **Минус:** Нужно как-то безопасно передать ключ (для этого и нужно асимметричное шифрование в начале).

**Аналогия:** Асимметричное — как сейф с двумя ключами (один у тебя, другой у банка). Симметричное — как один ключ от квартиры, который ты передаёшь другу через сейф.

---

## 4. Важные концепции, которые нужно понимать

### 1. CORS (Cross-Origin Resource Sharing)

**Что это:** Защита браузера от злоумышленников.

**Проблема:** Если JavaScript на сайте `evil.com` попытается сделать запрос к `api.bank.com` и украсть твои данные, браузер должен это заблокировать.

**Как работает:**
-   Браузер проверяет: "Откуда пришёл запрос?" (Origin).
-   Если запрос идёт с другого домена (`site-a.com` → `api.site-b.com`), браузер спрашивает у `site-b`: "Можно ли `site-a` делать запросы к тебе?"
-   Если `site-b` не разрешил (нет нужных заголовков), браузер блокирует запрос.

**Preflight Request (OPTIONS):**
-   Для некоторых типов запросов (POST с кастомными заголовками) браузер сначала отправляет запрос `OPTIONS`: "Можно я сделаю POST?"
-   Сервер отвечает: "Да, можно" или "Нет, нельзя".
-   Только после этого отправляется настоящий запрос.

**Заголовки, которые нужны:**
-   `Access-Control-Allow-Origin: https://site-a.com` — "Разрешаю запросы с `site-a.com`".
-   `Access-Control-Allow-Methods: GET, POST` — "Разрешаю методы GET и POST".

### 2. Keep-Alive (постоянное соединение)

**Проблема:** Открытие TCP/TLS соединения дорогое (см. выше — это 150-300мс).

**Решение:** HTTP/1.1 по умолчанию держит соединение открытым (`Connection: keep-alive`). После первого запроса соединение не закрывается, и следующие запросы идут сразу, без нового "рукопожатия".

**Аналогия:** Как телефонный разговор. Вместо того чтобы звонить каждый раз заново, ты остаёшься на линии и можешь задавать вопросы сразу.

### 3. Content Negotiation (договорённость о формате)

Браузер и сервер договариваются, в каком формате обмениваться данными.

**Примеры заголовков:**

-   `Accept: application/json` — "Я понимаю JSON, пришли данные в JSON".
-   `Accept-Encoding: gzip, br` — "Я понимаю сжатие Gzip и Brotli, сожми данные".
    -   **Gzip** — старый способ сжатия.
    -   **Brotli** — новый способ, сжимает лучше (меньше размер файла).
-   `Accept-Language: en-US, ru` — "Пришли текст на английском (американском) или русском".

**Зачем:** Чтобы сервер мог отправить данные в формате, который браузер понимает, и сжать их, чтобы передать быстрее.

### 4. CDN (Content Delivery Network)

**Что это:** Сеть серверов по всему миру, которые хранят копии твоего сайта.

**Зачем:**
-   **Ближе к пользователю:** Если твой сервер в Москве, а пользователь в Нью-Йорке, данные идут долго. CDN хранит копию в Нью-Йорке, и пользователь получает данные быстро.
-   **Разгрузка основного сервера:** CDN отдаёт статику (картинки, CSS, JS), а твой сервер занимается только динамикой (API).
-   **TCP/TLS Termination:** CDN берёт на себя "рукопожатия" (TCP/TLS), что экономит время.

**Аналогия:** Как сеть магазинов. Вместо того чтобы ехать на склад в другом городе, ты идёшь в ближайший магазин.

---

## 5. Чек-лист: как сделать сайт быстрее

### 1. Уменьшай количество запросов

**Проблема:** Каждый запрос = время на DNS + TCP + TLS + передачу данных.

**Решения:**
-   **Бандлинг** (Webpack, Vite) — склеить много маленьких файлов в один большой.
-   **HTTP/2** — можно отправлять много запросов параллельно (но всё равно лучше меньше).

### 2. Уменьшай размер файлов

**Решения:**
-   **Минификация** — убрать пробелы, комментарии, сократить имена переменных.
-   **Сжатие** — Gzip или Brotli (сервер сжимает, браузер распаковывает).
-   **Оптимизация картинок** — WebP или AVIF вместо PNG/JPG (меньше размер при том же качестве).

### 3. Приближай контент к пользователю

**Решение:** Используй CDN. Если пользователь в Азии, а сервер в Европе, CDN отдаст данные из Азии.

### 4. Кэшируй правильно

**Что это:** Сохранять данные в памяти, чтобы не запрашивать их снова.

**Как:** Правильные заголовки `Cache-Control`:
-   `Cache-Control: max-age=3600` — "Храни в памяти 1 час".
-   `Cache-Control: immutable` — "Этот файл никогда не изменится (например, `bundle.abc123.js`), храни вечно".

### 5. Подсказывай браузеру, что загрузить заранее

**Preload:** "Этот файл точно понадобится, загрузи его прямо сейчас".
```html
<link rel="preload" href="/fonts/main.woff2" as="font">
```

**Prefetch:** "Этот файл может понадобиться, загрузи его в свободное время".
```html
<link rel="prefetch" href="/next-page.html">
```

---

## Итого: что происходит, когда ты открываешь сайт?

1.  **DNS Lookup:** Браузер узнаёт IP-адрес сайта (20-200мс).
2.  **TCP Handshake:** Устанавливается соединение (50-150мс).
3.  **TLS Handshake:** Устанавливается безопасное соединение (если HTTPS) (100-200мс).
4.  **HTTP Request:** Браузер отправляет запрос "Дай мне главную страницу".
5.  **HTTP Response:** Сервер отправляет HTML, CSS, JS, картинки.
6.  **Рендеринг:** Браузер показывает страницу.

**Общее время до первого байта (TTFB — Time To First Byte):** 200-500мс на быстром интернете, 1-3 секунды на медленном.

**Вот почему важно:**
-   Использовать CDN (уменьшает время до сервера).
-   Кэшировать (не делать запросы повторно).
-   Сжимать данные (меньше передавать).
-   Использовать HTTP/2 или HTTP/3 (быстрее передача).
