
# Конспект: React, Next.js, Vite, TS, SSR/SSG/ISR

---

## 1. Что такое Next.js
- Next.js — это фреймворк поверх React.
- React сам по себе — библиотека для интерфейсов (UI). Он позволяет собирать «детали» (кнопки, карточки, меню).
- Next добавляет к этому:
  - Маршрутизацию (каждая папка = страница).
  - SSR (Server-Side Rendering) — рендер на сервере.
  - SSG/ISR — статическая генерация и автоматическое обновление страниц.
  - API-роуты — быстрые серверные ручки внутри проекта.
  - Оптимизацию ресурсов (изображения, шрифты, CSS).
- Для новостного сайта это важно, потому что:
  - страницы быстро загружаются,
  - статьи индексируются поисковиками,
  - можно автоматически обновлять контент.

---

## 2. Встроенный бандлер в Next
- Бандлер = сборщик кода.
- Он нужен, потому что браузер не понимает TypeScript и JSX, а также плохо работает с сотнями маленьких файлов.
- Бандлер делает:
  - Склеивает модули в удобные пакеты (code splitting, tree shaking).
  - Преобразует TS и JSX в чистый JS.
  - Сжимает файлы, оптимизирует картинки, CSS.
  - Даёт dev-сервер с «горячей перезагрузкой» (HMR).
- В Next бандлер встроен. Раньше это был Webpack, теперь — Turbopack (написан на Rust, быстрее).

---

## 3. Next.js vs Vite
- Vite: инструмент сборки. Быстрый, минималистичный. Не даёт страниц, SSR, маршрутов — только сборку.
- Next.js: полноценный фреймворк, сразу со всем нужным для реального сайта.

| Вопрос | Next.js | Vite |
|--------|---------|------|
| Класс | Фреймворк (React + SSR/SSG/ISR + API) | Инструмент сборки |
| Маршруты | Файловая система | Ставишь сам (React Router) |
| SSR/SSG/ISR | Из коробки | Нужно подключать плагины |
| SEO | Упрощено | Настраиваешь вручную |
| API-роуты | Есть | Нет |
| Когда брать | Новости, блоги, e-commerce | SPA, админки, виджеты |

**Аналогия:**
- Vite = мотор и коробка передач, ставишь куда хочешь.
- Next = уже собранная машина с мотором внутри.

---

## 4. SEO
- SEO (Search Engine Optimization) = как сделать сайт дружелюбным к Google.
- Важно: скорость загрузки, структура HTML, удобные ссылки.
- Для новостного сайта: без SEO никто не увидит твои статьи.

---

## 5. SSR, SSG, ISR
- SSR (Server-Side Rendering) = сервер собирает страницу при каждом запросе.  
  Пример: SpeedTypingTest на Flask — классический SSR.
- SSG (Static Site Generation) = страницы генерируются заранее при сборке. Быстро, но изменения нужно пересобирать.
- ISR (Incremental Static Regeneration) = гибрид: страница заранее статична, но Next автоматически пересобирает её каждые N минут.

**Аналогия:**
- SSR = готовим еду при заказе.
- SSG = накрыли фуршет заранее.
- ISR = фуршет, но повар обновляет блюда каждые 5 минут.

---

## 6. Почему твой SpeedTypingTest работал без сборщика
- Там был Flask + HTML-шаблоны + чистый JS.
- Ты подключал JS через `<script type="module">`, и современные браузеры умеют читать такие ES-модули напрямую.
- Flask просто отдавал HTML и статику → браузер выполнял.
- Сборщик не нужен, потому что не было TypeScript и JSX.

Можно было прикрутить Vite, но:
- пришлось бы писать конфиги,
- на маленьком проекте это не дало бы большой пользы.

---

## 7. TypeScript и «прогон через TS»
- TypeScript (TS) = это JS + типы.
- Пример:

```ts
let title: string = "AI News";
```

Браузер не понимает `: string`.

- Когда ты пишешь `.ts` или `.tsx`, Next:
  1. Проверяет типы (type-checking).
  2. Убирает типы и превращает код в чистый JS (transpile).
  3. JSX (`<h2>`) превращает в `React.createElement(...)`.

**Итог**: ты пишешь «на улучшенном JS для разработчика», а браузер получает обычный JS.

---

## 8. React/Next = JS или TS?
- React/Next = фреймворк/библиотека, не язык.
- Код можно писать на JS (`.js/.jsx`) или TS (`.ts/.tsx`).
- JSX/TSX — это просто синтаксис, который сборщик превращает в JS.

**Почему выбирают TS:**
- легче поддерживать большие проекты,
- меньше багов,
- типы документируют код.

---

## 9. Мини-структура Next-проекта

```
src/
  app/
    layout.tsx           // общий каркас
    page.tsx             // главная лента (SSR/ISR)
    article/[slug]/      // страница статьи
    api/
      subscribe/route.ts // API-подписка
      bookmarks/route.ts // API-закладки
  components/
    ArticleCard.tsx
    Header.tsx
    Footer.tsx
  lib/
    fetchNews.ts         // загрузка/нормализация данных
    formatDate.ts
  styles/
    globals.css
```

---

## 10. Основные выводы
1. SpeedTypingTest жил без сборщика, потому что был на чистом JS + Flask.
2. В React/Next без сборщика никак: нужен для JSX, TS, оптимизаций.
3. Next даёт встроенный Turbopack → тебе не нужно писать код под сборщик.
4. SEO, SSR, SSG, ISR — это про то, как страницы видят и люди, и поисковики.
5. Ты сам выбираешь: писать на JS или на TS. Для серьёзных проектов почти всегда лучше TS.

---

## Жизненный путь кода в Next

```
[Ты пишешь код]
 page.tsx
 └── TypeScript + JSX
     (типы + HTML в JS)

        │
        ▼
[Next.js / Turbopack]
 ├─ Проверка типов (TS)
 ├─ Убирает типы
 ├─ Превращает JSX → React.createElement
 ├─ Склеивает модули (import/export)
 ├─ Оптимизирует (tree-shaking, code-splitting)
 └─ Минифицирует

        │
        ▼
[Готовый JS + HTML]
 ├─ Чистый JavaScript
 ├─ HTML-страница с вшитым контентом (SSR/SSG/ISR)
 └─ Оптимизированные CSS/картинки/шрифты

        │
        ▼
[Браузер пользователя]
 ├─ Мгновенно показывает HTML
 ├─ Подключает JS для интерактива
 └─ Загружает только нужные куски кода
```
