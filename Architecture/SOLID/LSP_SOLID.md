# Конспект: L — Liskov Substitution Principle (Принцип подстановки Лисков)

## 1. Определение
- Сформулировала Барбара Лисков (1987):  
  **«Если `S` — подтип `T`, то объекты типа `T` могут быть заменены объектами типа `S` без нарушения корректности программы».**  
- Подклассы должны быть **взаимозаменяемыми** с базовыми классами.

## 2. Смысл
- Если код написан под базовый класс, он должен работать и с наследником **без изменений**.  
- Наследник не должен ломать обещания базового типа.  

## 3. Нарушения LSP (❌)
1. **Подкласс убивает функционал.**  
   ```python
   class Bird:
       def fly(self): print("Я лечу!")

   class Penguin(Bird):
       def fly(self): raise RuntimeError("Я не летаю!")
   ```
   Код, который вызывает `bird.fly()`, падает на пингвине.  

2. **Подкласс меняет контракт.**  
   - Базовый метод возвращает объект → наследник возвращает строку.  
   - Клиенты ломаются, так как ожидали один формат данных.  

3. **Подкласс добавляет неожиданные побочные эффекты.**  
   - В базовом `start()` просто запускается таймер.  
   - В наследнике `start()` ещё и очищает результаты.  
   - Контроллер этого не ждал.

## 4. Соблюдение LSP (✅)
- Подклассы сохраняют поведение, расширяя, а не ломая его.  
- Если контракт базового класса не подходит — **раздели интерфейсы**.  

### Пример: разделение интерфейсов
```python
class Bird: pass

class FlyableBird(Bird):
    def fly(self): ...

class Sparrow(FlyableBird):
    def fly(self): print("Вжжж!")

class Penguin(Bird):
    def swim(self): print("Плюх-плюх!")
```
Теперь функция, которая ждёт `FlyableBird`, не примет пингвина, и ошибки не будет.

## 5. Практика на SpeedTypingTest
- Базовый контракт таймера:  
  ```python
  class ITimer:
      def start(self): ...
      def stop(self): ...
      def on_done(self, cb): ...
  ```

- **Хорошо:**  
  - `HighPrecisionTimer` — считает точнее, но всё равно тикает и вызывает `on_done()`.  
  - `WorkerTimer` — тикает из воркера, но сохраняет поведение.  

- **Плохо:**  
  - `CheatTimer` в `start()` сразу вызывает `on_done(0)` → ломает ожидания клиента (контроллер ждал тики и завершение).  

## 6. Почему «ломается везде»
- Базовый класс обещает поведение (например, «все птицы летают»).  
- Если подкласс нарушает это обещание (`Penguin.fly()` кидает ошибку), клиентский код, который рассчитывал на контракт, ломается.  
- Тогда придётся в каждом месте писать проверки `if isinstance(bird, Penguin)` → расползание костылей.  
- LSP как раз нужен, чтобы **не пришлось менять клиентов** при появлении новых подклассов.

## 7. Чеклист для LSP
- Подкласс должен **сохранять семантику** методов базового класса.  
- Подкласс может **расширять**, но не ломать поведение.  
- Если поведение разное — дели интерфейсы (`Flyable`, `Swimmable`) или используй композицию (стратегии).  

## 8. Главное, что вынести
- **LSP защищает клиентов.**  
- Подтипы должны быть полностью взаимозаменяемыми с базовым типом.  
- Если это невозможно — значит, иерархия построена неправильно.  
