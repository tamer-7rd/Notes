# Конспект: OCP (Open/Closed Principle)

## 1. Суть принципа
- **Определение:** Код должен быть **открыт для расширения, но закрыт для модификации**.  
- **Смысл:** новые фичи должны добавляться через **расширение** (наследование, композиция, декораторы), а не через переписывание старого кода.  
- **Важно:** это **цель**, а не жёсткий запрет. Иногда рефакторинг старого кода неизбежен.

## 2. Публичный контракт
- Это то, что **видит и использует внешний мир** (другие модули, клиенты).  
- Примеры: интерфейсы (`ITimer`), API (`/api/results`), публичные методы (`timer.start()`).  
- **Правило:** публичный контракт должен меняться как можно реже.  
- **Почему:** изменение контракта ломает всех клиентов → приходится чинить много кода.  

## 3. Внутренние изменения
- Внутри модуля можно свободно рефакторить:  
  - переписать таймер с `setInterval` на `requestAnimationFrame`;  
  - добавить паузу или штрафы через декораторы;  
  - вынести формулы в отдельные функции.  
- Пока контракт (`start()`, `onDone()`) остаётся прежним, внешний код изменений не замечает.  

## 4. Порты (стабильные интерфейсы)
- **Порт (интерфейс)** — это стабильный договор, через который контроллер общается с реализацией.  
- Пример: `ITimer` с методами `start/pause/resume/stop` и событиями `tick/done`.  
- **Зачем:** чтобы разные реализации (старый таймер, новый high-precision, worker-таймер) были взаимозаменяемыми.  
- **Когда нужен порт:**  
  - когда часть системы **часто меняется**;  
  - когда предполагается несколько реализаций;  
  - когда надо изолировать внешних клиентов от деталей реализации.  

## 5. Адаптеры
- **Адаптер** — «переводчик» между старым или сторонним кодом и портом.  
- Нужен, если старая реализация не соответствует интерфейсу.  
- Пример: старый `timer.js` не имел `onDone()`, адаптер добавляет его для соответствия `ITimer`.  
- **Правило:** адаптеры нужны редко и временно. Их задача — плавный переход.  

## 6. Декораторы (обёртки)
- **Декоратор** — обёртка, добавляющая поведение, не ломая контракт.  
- Примеры:  
  - `PausableTimer` — фильтрует события во время паузы;  
  - `PenaltyTimer` — добавляет штрафное время за ошибки.  
- Отличие от адаптера: адаптер «подгоняет интерфейс», декоратор «расширяет поведение».  

## 7. Контроллер
- **Контроллер** — это «склейка» между UI/внешним миром и логикой.  
- В твоём проекте это `typingTest.js`: запускает таймер, слушает события, считает результат, обновляет UI.  
- Контроллер должен зависеть только от порта (`ITimer`), а не от конкретного таймера.  
- Тогда при замене реализации таймера контроллер не меняется.  

## 8. Практика на SpeedTypingTest
- Сейчас: контроллер напрямую зависит от таймера → при изменении таймера приходится менять контроллер.  
- После введения порта `ITimer`:  
  - Старый таймер → обёрнут адаптером `LegacyTimerAdapter`.  
  - Контроллер работает только с `ITimer`.  
  - Новые таймеры (HighPrecision, Worker) пишутся сразу под `ITimer`.  
  - Декораторы (`PausableTimer`, `PenaltyTimer`) расширяют поведение без ломки контроллера.  
- Итог: контроллер остаётся «закрыт», а таймеры можно расширять бесконечно.  

## 9. Чеклист «Нужен ли порт?»
Задай себе 3 вопроса:  
1. Эта часть системы **будет меняться** или у неё может быть несколько реализаций?  
2. Если она изменится, пострадает **много кода/модулей**?  
3. Есть ли смысл иметь разные варианты (например, таймер обычный и high-precision)?  

- Если «да» хотя бы на один → порт нужен.  
- Если «нет» на все → делай простую реализацию, не усложняй.

## 10. Главное, что вынести
- OCP не значит «никогда не менять код».  
- Это значит: **меняй так, чтобы в будущем менять было не нужно.**  
- Один стабильный контракт → много реализаций.  
- Адаптеры — для старого кода, декораторы — для расширений.  
- Контроллеры должны видеть только контракт, а не детали.  
