# D — Dependency Inversion Principle (Принцип инверсии зависимостей)

## Суть принципа
DIP — это последний принцип из SOLID. Он звучит так:  
Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Простыми словами:
- Главная программа (высокоуровневый модуль) не должна напрямую привязываться к конкретным реализациям (низкоуровневым деталям).
- Нужно строить зависимость через интерфейсы или абстрактные классы.

---

## Почему это важно?

Если верхний уровень зависит от деталей, любое изменение в этих деталях ломает всю систему.  
DIP делает код:
- более гибким (легко заменить реализацию),
- более тестируемым (можно подменять зависимости моками),
- более устойчивым к изменениям.

---

## Пример без DIP
```python
class MySQLDatabase:
    def connect(self):
        print("Connecting to MySQL...")

class Application:
    def __init__(self):
        self.db = MySQLDatabase()  # Жёсткая привязка
    def start(self):
        self.db.connect()
```

Здесь Application зависит от конкретного MySQLDatabase. Если завтра решим перейти на PostgreSQL, придётся лезть в код Application.

---

## Пример с DIP
```python
from abc import ABC, abstractmethod

# Абстракция (интерфейс)
class Database(ABC):
    @abstractmethod
    def connect(self):
        pass

# Реализации
class MySQLDatabase(Database):
    def connect(self):
        print("Connecting to MySQL...")

class PostgreSQLDatabase(Database):
    def connect(self):
        print("Connecting to PostgreSQL...")

# Верхний уровень зависит от абстракции, а не от деталей
class Application:
    def __init__(self, db: Database):
        self.db = db
    def start(self):
        self.db.connect()

# Использование
app = Application(PostgreSQLDatabase())
app.start()
```

Теперь Application не знает, какой именно тип базы подключён — MySQL, PostgreSQL или даже FakeDatabase для тестов.  
Детали зависят от абстракции, а не наоборот.

---

## Ключевая мысль
DIP = “Зависеть от интерфейса, а не от реализации”.  
Именно поэтому часто говорят: “Программируй на уровне абстракций, а не деталей.”

---

Фраза «Программируй на уровне абстракций, а не деталей» — это как золотое правило инженера: думай в терминах “что должно делаться”, а не “как именно оно делается”.

---

## Абстракции
Абстракция — это «договор», описание поведения, интерфейс. Она говорит:
- Что должно быть сделано,
- но не говорит как именно это реализовано.

В коде абстракция — это:
- интерфейс,
- абстрактный класс,
- иногда просто набор функций с заранее определёнными входами и выходами.

Пример (Python):
```python
from abc import ABC, abstractmethod

class PaymentSystem(ABC):  # абстракция
    @abstractmethod
    def pay(self, amount):
        pass
```

Абстракция = «нужно уметь оплачивать».

---

## Детали
Детали — это конкретные реализации. То есть «как именно мы реализуем абстракцию».
- В какой БД хранить данные: MySQL, PostgreSQL, MongoDB.
- Как оплатить: Visa, PayPal, криптовалюта.
- Как логировать: писать в файл или отправлять на сервер.

Пример (детали реализации):
```python
class PayPalPayment(PaymentSystem):
    def pay(self, amount):
        print(f"Оплата {amount}$ через PayPal")

class CryptoPayment(PaymentSystem):
    def pay(self, amount):
        print(f"Оплата {amount}$ через Bitcoin")
```

---

## В связке
Если твой код зависит от деталей (например, класс Application сам создаёт PayPalPayment), ты становишься заложником конкретной реализации.  
Если код зависит от абстракции (PaymentSystem), ты можешь подменить детали хоть завтра, не ломая всю архитектуру.

---

## Жизненная аналогия
Абстракция = «я хочу добраться до другой страны на самолёте».  
Детали = Boeing, Airbus или частный джет.

Ты планируешь на уровне абстракции (самолёт), а не на уровне детали (какая именно модель самолёта). Благодаря этому у тебя есть свобода выбора.
