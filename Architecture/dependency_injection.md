# Dependency Injection (DI) и принцип инверсии зависимостей

---

## Что за зверь DI?

Dependency Injection = инъекция зависимостей.  
Идея простая: объект не создаёт то, от чего зависит, а получает это извне.

---

## Проблема без DI

Допустим, у тебя есть сервис, который должен работать с базой данных:

```python
class UserService:
    def __init__(self):
        self.db = Database()   # зависимость создаётся внутри!

    def get_user(self, user_id):
        return self.db.query(f"SELECT * FROM users WHERE id={user_id}")
```

Что не так?
- Ты жёстко привязан к конкретному Database.
- Хочешь заменить базу на FakeDatabase для тестов? Придётся менять код внутри класса.
- Хочешь завтра перейти с PostgreSQL на MongoDB? Опять менять UserService.

→ Это называется жёсткая связанность.

---

## Как это лечит DI

DI говорит: «Не создавай зависимости внутри, получай их снаружи».

```python
class UserService:
    def __init__(self, db):   # зависимость приходит извне
        self.db = db

    def get_user(self, user_id):
        return self.db.query(f"SELECT * FROM users WHERE id={user_id}")
```

Теперь:

```python
db = Database()               # конкретную реализацию решаем тут
user_service = UserService(db)
```

Для тестов:

```python
fake_db = FakeDatabase()
user_service = UserService(fake_db)
```

→ UserService теперь не знает, какая именно база внутри. Он работает через абстракцию (контракт: у объекта есть метод query).

---

## Почему это важно
1. Тестируемость — можно подставить фейковые зависимости (mock, stub).
2. Расширяемость — легко заменить реализацию, не трогая бизнес-логику.
3. Слабая связанность — классы меньше знают друг о друге → код живёт дольше.
4. Конфигурируемость — в бою одно, в тестах другое, в отладке третье.

---

## Варианты внедрения
1. Через конструктор (как в примере выше).  
   Самый популярный способ.

2. Через сеттеры (передаёшь зависимость методом после создания объекта).

```python
user_service = UserService()
user_service.set_db(Database())
```

3. Через параметры методов (иногда удобно для мелких зависимостей).

```python
def get_user(self, db, user_id):
    return db.query("...")
```

4. Через контейнер (IoC-контейнер)  
   Это когда есть «коробка», которая знает, как строить все зависимости, и сам их прокидывает. Это уже уровень фреймворков (например, NestJS или Spring).

---

## Архитектурный смысл

DI = реализация принципа инверсии зависимостей (D из SOLID):  
- высокоуровневые модули не должны зависеть от низкоуровневых;  
- и те, и другие должны зависеть от абстракций.

---

Можно думать так:  
Без DI — ты сам идёшь в магазин за продуктами каждый раз, когда готовишь.  
С DI — у тебя есть поставщик (или холодильник), который уже всё принёс. Ты готовишь, не думая, откуда продукты.  

---

## DIP vs DI

Dependency Injection (DI) — это практический механизм, чтобы воплотить DIP.  
- DIP = принцип: завязывайся на абстракции, а не на детали.  
- DI = способ: как именно передавать реализации (через конструктор, параметры, контейнер).  

То есть DIP задаёт философию, а DI даёт инструменты.
