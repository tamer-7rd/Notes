# Конспект: Архитектура MVC

## 1. Определение
**MVC (Model–View–Controller)** — архитектурный шаблон, разделяющий приложение на три части:

1. **Model (Модель)** — хранит данные и бизнес-логику.
2. **View (Представление)** — отвечает за отображение данных пользователю.
3. **Controller (Контроллер)** — принимает команды, связывает Модель и Представление.

**Главная цель:** разделить обязанности, чтобы код был чище, проще в поддержке и расширении.

---

## 2. Принцип работы MVC

Пользователь → View → Controller → Model
↑
←

1. Пользователь взаимодействует с **View** (нажимает кнопки, вводит текст).
2. **Controller** обрабатывает это действие и обращается к **Model**.
3. **Model** меняет данные и возвращает результат.
4. **View** обновляется и показывает новые данные пользователю.

---

## 3. Пример на бэкенде (JavaScript + Express)

**Model (model.js)**
```js
let tasks = [];

function addTask(task) {
  tasks.push(task);
}

function getTasks() {
  return tasks;
}

module.exports = { addTask, getTasks };
```

**Controller (controller.js)**
```js
const model = require('./model');

function handleGetTasks(req, res) {
  res.send(model.getTasks());
}

function handleAddTask(req, res) {
  model.addTask(req.body.task);
  res.send('Task added');
}

module.exports = { handleGetTasks, handleAddTask };
```

**View (в API — это JSON)**
```json
[
  { "task": "Купить хлеб" },
  { "task": "Сделать зарядку" }
]
```


⸻

4. Пример на фронтенде (чистый JS)

**HTML + JS**
```html
<ul id="taskList"></ul>
<input id="taskInput" type="text">
<button id="addBtn">Добавить</button>

<script>
// Model
let tasks = [];

// Controller
document.getElementById('addBtn').addEventListener('click', () => {
  const input = document.getElementById('taskInput');
  tasks.push(input.value);
  input.value = '';
  render(); // обновляем View
});

// View
function render() {
  const list = document.getElementById('taskList');
  list.innerHTML = '';
  tasks.forEach(task => {
    const li = document.createElement('li');
    li.textContent = task;
    list.appendChild(li);
  });
}
</script>
```


⸻

5. Применение во фронте и бэке
	•	Фронтенд:
	•	Model = данные (state) или полученные из API.
	•	Controller = обработчики событий (кнопки, формы).
	•	View = HTML/CSS, которые видит пользователь.
	•	Бэкенд:
	•	Model = работа с базой данных или файлами.
	•	Controller = обработка HTTP-запросов.
	•	View = HTML-страницы или JSON-ответ.

⸻

6. Визуальная схема

[Пользователь] → (View) → (Controller) → (Model) → Данные
                   ↑           ↓
                   ← ← ← ← ← ← ←

	•	View — интерфейс (HTML, кнопки, таблицы).
	•	Controller — «мозг» программы.
	•	Model — хранение данных и логики.

⸻

7. Чек-лист для самопроверки (MVC)
	•	Модель и данные находятся в отдельном месте.
	•	Отображение (View) не меняет данные напрямую.
	•	Есть «связующее звено» (Controller), которое управляет логикой.
	•	Изменение в одной части (Model/View) не ломает остальные.
	•	Логика и представление не перемешаны в одном большом куске кода.

⸻






# Архитектурные паттерны: MVC и MVP

## 1. Когда используется архитектура (MVC / MVP и др.)
- **Маленькие проекты / прототипы (MVP-продукт):**
  - Архитектуру часто упрощают или нарушают.
  - Цель — быстро проверить идею, собрать обратную связь.
  - Код может быть «грязным», главное — скорость.
  - Если гипотеза подтверждается → проект переписывают по правилам.

- **Средние проекты:**
  - Используется фреймворк, который диктует архитектуру:
    - Flask/Django → MVC-подобная.
    - React → MVVM (через state).
    - Angular → строгий MVVM.
  - Следуют правилам выбранного фреймворка, а не чистому MVC.

- **Большие компании:**
  - Архитектура задаётся с самого начала (MVC, MVVM, микросервисы, DDD).
  - Система должна быть масштабируемой и поддерживаемой годами.
  - Ошибки архитектуры дорого обходятся → строгая дисциплина.

---

## 2. Альтернативы MVC
- **MVP (Model–View–Presenter):**
  - View пассивный, работает только через Presenter.
  - Presenter контролирует всю логику.

- **MVVM (Model–View–ViewModel):**
  - Популярен во фронтенде (React, Angular, Vue).
  - View ↔ ViewModel связаны двусторонним биндингом.
  - Удобно при сложных интерфейсах.

- **Код без архитектуры (скрипты в одном файле):**
  - Подходит для маленьких демо или игрушек.
  - Минус — плохо поддерживаемо при росте.

---

## 3. Кто контролирует архитектуру
- **Project Manager (PM):**
  - Отвечает за сроки и бизнес-цели.
  - Не определяет архитектуру.

- **Software Architect / Team Lead:**
  - Решают, какой паттерн использовать.
  - Контролируют код-ревью и следят за соблюдением правил.

- **Фреймворк:**
  - На практике чаще всего именно он задаёт архитектурный стиль.
  - Разработчики подстраиваются под шаблон, а не изобретают с нуля.

---

## 4. Итог
- Архитектура = поддерживаемость + масштабируемость.
- На старте (MVP-продукт) архитектуру можно упростить.
- В зрелых проектах — соблюдают строго.
- Решение принимает архитектор/тимлид, а PM отвечает за сроки.
- Для фронтенда есть варианты: **MVC, MVP, MVVM** — выбор зависит от стека и масштаба.